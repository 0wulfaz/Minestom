import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import net.minestom.server.registry.ResourceGatherer;
import net.minestom.server.utils.NamespaceID;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.net.URL;
import java.util.*;

/**
 * Generates a Block enum containing all data about blocks
 */
public class BlockEnumGenerator {

    private static final Logger LOGGER = LoggerFactory.getLogger(BlockEnumGenerator.class);

    private static final String DEFAULT_TARGET_PATH = "src/autogenerated/java";
    public static final String MC_DATA_BLOCKS_PATH = "minecraft_data/reports/blocks.json";
    public static final String PRISMARINE_JS_DATA_PATHS = "prismarine-minecraft-data/data/dataPaths.json";
    public static final String BURGER_URL_BASE_URL = "https://pokechu22.github.io/Burger/";

    public static void main(String[] args) throws IOException {
        try {
            ResourceGatherer.ensureResourcesArePresent(null); // TODO
        } catch (IOException e) {
            e.printStackTrace();
        }
        String targetVersion = "1.15.2";
        if(args.length >= 1) {
            targetVersion = args[0];
        }

        String targetPart = DEFAULT_TARGET_PATH;
        if(args.length >= 2) {
            targetPart = args[1];
        }

        File targetFolder = new File(targetPart);
        if(!targetFolder.exists()) {
            targetFolder.mkdirs();
        }

        Gson gson = new Gson();

        // load report blocks and block states
        LOGGER.debug("Loading information from data extraction");
        List<DataReportBlock> dataBlocks = parseBlocksFromMCData(gson, MC_DATA_BLOCKS_PATH);
        // load properties from Prismarine
        LOGGER.debug("Finding path for PrismarineJS blocks");
        JsonObject dataPaths = gson.fromJson(new BufferedReader(new FileReader(PRISMARINE_JS_DATA_PATHS)), JsonObject.class);
        JsonObject pathsJson = dataPaths.getAsJsonObject("pc").getAsJsonObject(targetVersion);

        PrismarinePaths paths = gson.fromJson(pathsJson, PrismarinePaths.class);
        LOGGER.debug("Loading PrismarineJS blocks data");
        List<PrismarineJSBlock> prismarineJSBlocks = parseBlocksFromPrismarineJS(gson, paths.getBlockFile());

        LOGGER.debug("Loading Burger blocks data (requires Internet connection)");
        List<BurgerBlock> burgerBlocks = parseBlocksFromBurger(gson, BURGER_URL_BASE_URL+targetVersion+".json");

        LOGGER.debug("Compiling information");
        Collection<BlockContainer> blocks = compile(dataBlocks, prismarineJSBlocks, burgerBlocks);

        LOGGER.debug("Compilation finished, code generation can now begin");

        generateEnum(targetPart, blocks);
        LOGGER.debug("Finished!");
    }

    private static void generateEnum(String targetPart, Collection<BlockContainer> blocks) throws IOException {
        String packageName = "net.minestom.instance.block";
        String folder = packageName.replace(".", "/");
        String className = "TmpBlock";
        EnumGenerator blockGenerator = new EnumGenerator(packageName, className);
        blockGenerator.setParams("String namespaceID", "short defaultID", "double hardness", "double resistance", "boolean isAir", "boolean isSolid");
        blockGenerator.addMethod("getId", "short", "return defaultID;");
        blockGenerator.addMethod("isAir", "boolean", "return isAir;");
        blockGenerator.addMethod("isSolid", "boolean", "return isSolid;");
        blockGenerator.addMethod("getHardness", "double", "return hardness;");
        blockGenerator.addMethod("getResistance", "double", "return resistance;");
        blockGenerator.addMethod("breaksInstantaneously", "boolean", "return hardness == 0;");
        LOGGER.debug("Generating enum");
        for (BlockContainer block : blocks) {
            blockGenerator.addInstance(block.getId().getPath().toUpperCase(), "\""+block.getId().toString()+"\"", "(short) "+block.getDefaultState().getId(), block.getHardness(), block.getResistance(), block.isAir(), block.isSolid());
        }

        File classFolder = new File(targetPart+"/"+folder);
        if(!classFolder.exists()) {
            classFolder.mkdirs();
        }
        LOGGER.debug("Writing enum to file: "+classFolder+"/"+className+".java");
        try(Writer writer = new BufferedWriter(new FileWriter(new File(classFolder, className+".java")))) {
            writer.write(blockGenerator.generate());
        }
    }

    /**
     * Compiles all block information in a single location
     * @param dataBlocks
     * @param prismarineJSBlocks
     * @param burgerBlocks
     */
    private static Collection<BlockContainer> compile(List<DataReportBlock> dataBlocks, List<PrismarineJSBlock> prismarineJSBlocks, List<BurgerBlock> burgerBlocks) {
        TreeSet<BlockContainer> blocks = new TreeSet<>(BlockContainer::compareTo);
        // ensure the 3 list have the same length and order
        dataBlocks.sort(Comparator.comparing(block -> block.name.toString()));
        prismarineJSBlocks.sort(Comparator.comparing(block -> NamespaceID.from(block.name).toString()));
        burgerBlocks.sort(Comparator.comparing(block -> NamespaceID.from(block.text_id).toString()));

        for (int i = 0; i < dataBlocks.size(); i++) {
            DataReportBlock data = dataBlocks.get(i);
            PrismarineJSBlock prismarine = prismarineJSBlocks.get(i);
            BurgerBlock burger = burgerBlocks.get(i);

            assert data.name.getPath().equals(prismarine.name) && prismarine.name.equalsIgnoreCase(burger.text_id);

            List<BlockContainer.BlockState> states = new LinkedList<>();
            for(DataReportBlock.BlockState s : data.states) {
                states.add(new BlockContainer.BlockState(s.id, s.properties));
            }

            BlockContainer.BlockState defaultState = new BlockContainer.BlockState(data.defaultState.id, data.defaultState.properties);

            BlockContainer block = new BlockContainer(prismarine.id, data.name, prismarine.hardness, burger.resistance, defaultState, states);
            if(!"empty".equals(prismarine.boundingBox)) {
                block.setSolid();
            }
            if(data.name.equals(NamespaceID.from("minecraft:water")) || data.name.equals(NamespaceID.from("minecraft:lava"))) {
                block.setLiquid();
            }

            blocks.add(block);
        }

        return blocks;
    }

    /**
     * Extracts block information from Burger
     * @param gson
     * @param url
     * @return
     * @throws IOException
     */
    private static List<BurgerBlock> parseBlocksFromBurger(Gson gson, String url) throws IOException {
        try(BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new URL(url).openStream()))) {
            LOGGER.debug("\tConnection established, reading file");
            JsonObject obj = gson.fromJson(bufferedReader, JsonArray.class).get(0).getAsJsonObject().getAsJsonObject("blocks").getAsJsonObject("block");

            LOGGER.debug("\tExtracting blocks");
            List<BurgerBlock> blocks = new LinkedList<>();
            for(var entry : obj.entrySet()) {
                BurgerBlock block = gson.fromJson(entry.getValue(), BurgerBlock.class);
                blocks.add(block);
            }

            return blocks;
        } catch (IOException e) {
            throw e;
        }
    }

    /**
     * Extract block information from PrismarineJS (submodule of Minestom)
     * @param gson
     * @param blockFile
     * @return
     * @throws IOException
     */
    private static List<PrismarineJSBlock> parseBlocksFromPrismarineJS(Gson gson, File blockFile) throws IOException {
        try(BufferedReader bufferedReader = new BufferedReader(new FileReader(blockFile))) {
            PrismarineJSBlock[] blocks = gson.fromJson(bufferedReader, PrismarineJSBlock[].class);
            return Arrays.asList(blocks);
        } catch (IOException e) {
            throw e;
        }
    }

    /**
     * Extract block information from reports generated by the data extractor present in minecraft_server.jar
     * @param gson
     * @param path
     * @return
     */
    private static List<DataReportBlock> parseBlocksFromMCData(Gson gson, String path) {
        List<DataReportBlock> blocks = new LinkedList<>();
        try {
            BufferedReader bufferedReader = new BufferedReader(new FileReader(path));

            JsonObject obj = gson.fromJson(bufferedReader, JsonObject.class);
            for(var entry : obj.entrySet()) {
                NamespaceID id = NamespaceID.from(entry.getKey());
                JsonElement blockInfo = entry.getValue();
                DataReportBlock block = gson.fromJson(blockInfo, DataReportBlock.class);
                block.bindDefaultState();
                block.name = id;

                blocks.add(block);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }


        return blocks;
    }
}
